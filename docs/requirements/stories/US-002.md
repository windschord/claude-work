# US-002: PTYセッションマネージャーの導入

## ユーザーストーリー

**As a** システム管理者
**I want** PTYセッションとWebSocket接続の管理が一元化される
**So that** セッションのライフサイクルが明確になり、トラブルシューティングと保守が容易になる

## 背景

### 現状の問題
現在、PTYセッション管理が複数のコンポーネントに分散しています：
- **ClaudePTYManager**: Claude Code用のPTYセッション管理
- **PTYManager**: シェルターミナル用のPTYセッション管理
- **WebSocketハンドラー**: 接続プールの管理
- **状態変数**: `activeConnections`, `creatingSessionPromises`, `destroyTimers`がメモリに分散

この分散により：
1. **状態管理の複雑性**: どこに何の状態があるか不明確
2. **ライフサイクル管理の困難**: セッション作成・破棄の流れが追いにくい
3. **再起動時の状態喪失**: サーバー再起動時にメモリ上の状態が失われる
4. **テストの困難性**: 状態が分散しているため単体テストが書きにくい

### US-001との関係
US-001でWebSocket接続管理が統一されました。本USでは、その接続プールとPTYセッションを統合管理する上位レイヤーを導入します。

## 受入基準（EARS記法）

### 機能要件

#### REQ-002-001: セッションの作成
- ユーザーがセッション作成をリクエストした時、システムはPTYSessionManagerを通じてPTYセッションと接続プールを作成しなければならない

#### REQ-002-002: セッションの取得
- WebSocket接続が確立された時、システムはPTYSessionManagerからセッションIDに対応するセッション情報を取得しなければならない

#### REQ-002-003: セッションの破棄
- セッション削除がリクエストされた時、システムはPTYSessionManagerを通じてPTYセッション、接続プール、タイマーをクリーンアップしなければならない

#### REQ-002-004: 状態の一元管理
- セッション状態を管理する時、システムはPTYSessionManager内で一元的に管理しなければならない

#### REQ-002-005: ライフサイクルイベント
- セッションが作成・破棄された時、システムは適切なライフサイクルイベントを発火しなければならない

#### REQ-002-006: 環境アダプターの統合
- セッション作成時、システムは環境タイプ（HOST/DOCKER/SSH）に応じてAdapterFactoryから適切なアダプターを取得しなければならない

#### REQ-002-007: WebSocketハンドラーの簡素化
- WebSocketハンドラーがPTYにアクセスする時、システムはPTYSessionManager経由でアクセスしなければならない

### 非機能要件

#### NFR-002-001: 拡張性
- 新しい環境タイプやセッションタイプを追加する時、システムはPTYSessionManagerを拡張するだけで対応できなければならない

#### NFR-002-002: テスタビリティ
- PTYSessionManagerは、モック可能なインターフェースを持たなければならない

#### NFR-002-003: 可視性
- セッション状態を確認する時、システムはPTYSessionManagerを通じてすべてのアクティブセッションを列挙できなければならない

## テストシナリオ

### シナリオ1: セッションのライフサイクル
**Given**: PTYSessionManagerが初期化されている
**When**: セッションを作成→接続→破棄する
**Then**:
- セッションが正しく作成される
- 接続プールが管理される
- 破棄時にすべてのリソースがクリーンアップされる

### シナリオ2: 複数セッションの同時管理
**Given**: PTYSessionManagerが初期化されている
**When**: 10個のセッションを同時に作成する
**Then**:
- すべてのセッションが独立して管理される
- セッションIDによる取得が正しく動作する
- 1つのセッション破棄が他に影響しない

### シナリオ3: 環境タイプの切り替え
**Given**: PTYSessionManagerが初期化されている
**When**: HOST環境とDOCKER環境のセッションを作成する
**Then**:
- 各環境に適したアダプターが使用される
- 環境ごとに適切なPTYセッションが作成される

### シナリオ4: エラーハンドリング
**Given**: セッション作成中にエラーが発生する
**When**: PTYSessionManagerによる検出
**Then**:
- 部分的に作成されたリソースがクリーンアップされる
- エラーが適切に報告される
- 他のセッションに影響しない

## 影響を受けるコンポーネント

### 新規作成するファイル
1. **src/services/pty-session-manager.ts**
   - PTYセッションと接続プールの統合管理
   - セッションライフサイクルの制御
   - 環境アダプターとの統合

### 修正が必要なファイル
1. **src/services/claude-pty-manager.ts**
   - PTYSessionManagerを使用するようにリファクタリング
   - 接続管理ロジックをPTYSessionManagerに移譲

2. **src/services/pty-manager.ts**
   - PTYSessionManagerを使用するようにリファクタリング
   - 接続管理ロジックをPTYSessionManagerに移譲

3. **src/lib/websocket/claude-ws.ts**
   - PTYSessionManager経由でPTYにアクセス

4. **src/lib/websocket/terminal-ws.ts**
   - PTYSessionManager経由でPTYにアクセス

### 再利用する既存コンポーネント
- **AdapterFactory**: 環境アダプターの選択
- **ConnectionManager**: 接続プール管理（US-001で拡張）
- **ScrollbackBuffer**: スクロールバックバッファ管理

## 依存関係

### 前提条件
- US-001: WebSocket接続管理の統一（完了必須）

### 後続タスク
- US-004: 状態管理の統一（PTYSessionManagerの状態を永続化）

### 並行可能なタスク
- US-003: Docker環境の安定化（独立して実装可能だが、本US完了後に統合）

## 実装のガイドライン

### アーキテクチャ設計
```
[WebSocketハンドラー]
       |
       v
[PTYSessionManager] ----+----> [ClaudePTYManager (legacy)]
       |                |
       |                +----> [PTYManager (legacy)]
       |                |
       |                +----> [AdapterFactory]
       |
       +----> [ConnectionManager]
       |
       +----> [セッション状態Map]
```

### PTYSessionManagerのインターフェース
```typescript
interface PTYSessionManager {
  createSession(sessionId: string, options: SessionOptions): Promise<PTYSession>
  getSession(sessionId: string): PTYSession | undefined
  destroySession(sessionId: string): Promise<void>
  listSessions(): string[]
  addConnection(sessionId: string, ws: WebSocket): void
  removeConnection(sessionId: string, ws: WebSocket): void
}

interface PTYSession {
  id: string
  pty: IPty
  connectionPool: Set<WebSocket>
  scrollbackBuffer: ScrollbackBuffer
  environmentType: 'HOST' | 'DOCKER' | 'SSH'
  metadata: SessionMetadata
}
```

### 主要な設計決定
1. **シングルトンパターン**: PTYSessionManagerはシングルトンとして実装
2. **Mapベースの管理**: セッションIDをキーとしたMapで管理
3. **イベントエミッター**: ライフサイクルイベントをEmitterで通知
4. **段階的リファクタリング**: 既存のClaudePTYManager/PTYManagerを内部で使用しつつ、段階的に統合

### 実装の順序
1. PTYSessionManagerの基本構造を作成
2. セッション作成・取得・破棄のメソッド実装
3. ConnectionManagerとの統合
4. ClaudePTYManagerのリファクタリング
5. PTYManagerのリファクタリング
6. WebSocketハンドラーの変更
7. 単体テストの作成
8. 統合テストの作成

## 検証方法

### 単体テスト
- [ ] セッション作成が正しく動作する
- [ ] セッション取得が正しく動作する
- [ ] セッション破棄がリソースをクリーンアップする
- [ ] 複数セッションの同時管理が正しく動作する
- [ ] エラー時のクリーンアップが動作する

### 統合テスト
- [ ] WebSocketハンドラーとの統合が正しく動作する
- [ ] 環境アダプターとの統合が正しく動作する
- [ ] ConnectionManagerとの統合が正しく動作する

### E2Eテスト（Playwright）
- [ ] セッション作成→接続→操作→破棄の流れが正しく動作する
- [ ] 複数セッションの同時操作が正しく動作する

### リグレッションテスト
- [ ] 既存のセッション管理機能が破壊されていない
- [ ] US-001で実装した機能が正しく動作する

## リスク

| リスク | 影響度 | 対策 |
|-------|--------|------|
| 既存コードの大規模リファクタリング | 高 | 段階的移行、既存マネージャーを内部で使用 |
| インターフェース設計のミス | 中 | US-001の実装経験を活かす、早期レビュー |
| パフォーマンスへの影響 | 低 | 軽量なラッパー実装、ベンチマークテスト |

## 見積もり

- **設計**: 6時間
- **実装**: 16時間
- **リファクタリング**: 8時間
- **テスト**: 8時間
- **合計**: 38時間（5日）

## 参照

- 元の実装計画: セッション管理の包括的改善計画 - ステップ2
- 依存US: US-001（WebSocket接続管理の統一）
- 既存実装:
  - src/services/claude-pty-manager.ts
  - src/services/pty-manager.ts
  - src/services/adapter-factory.ts

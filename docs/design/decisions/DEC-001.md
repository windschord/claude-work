# DEC-001: ConnectionManagerの拡張設計

## ステータス

**承認済**

## コンテキスト

現在、ClaudeWorkでは3種類のWebSocketサーバーが存在しますが、接続管理のアプローチが統一されていません：

- **Session WebSocket**: ConnectionManagerを使用して接続プールを管理
- **Claude WebSocket**: 独自の`activeConnections` Map管理
- **Terminal WebSocket**: 独自の`activeConnections` Map管理

この不統一により、以下の問題が発生しています：

1. **イベントハンドラーの重複登録**: 各WebSocket接続が独立したイベントハンドラーをPTYに登録
2. **メモリリーク**: 接続切断時にハンドラーが削除されない
3. **データ重複送信**: 同じデータが複数回ブロードキャストされる
4. **ブラウザごとに異なる表示**: スクロールバックバッファ送信のタイミング不整合

## 決定事項

**ConnectionManagerを拡張し、すべてのWebSocketタイプ（Session、Claude、Terminal）で使用する**

### 拡張内容

1. **接続プール管理**: `Map<sessionId, Set<WebSocket>>`で管理
2. **ブロードキャスト機能**: PTYからの出力を全接続に配信
3. **イベントハンドラー管理**: セッション単位で1つのハンドラーのみ登録
4. **スクロールバックバッファ管理**: 新規接続時に既存出力を送信

### インターフェース

```typescript
interface IConnectionManager {
  // 接続プール管理
  addConnection(sessionId: string, ws: WebSocket): void
  removeConnection(sessionId: string, ws: WebSocket): void
  getConnections(sessionId: string): Set<WebSocket>
  getConnectionCount(sessionId: string): number

  // ブロードキャスト
  broadcast(sessionId: string, message: string | Buffer): void

  // ハンドラー管理
  registerHandler(sessionId: string, eventName: string, handler: Function): void
  unregisterHandler(sessionId: string, eventName: string): void

  // クリーンアップ
  cleanup(sessionId: string): void
}
```

## 根拠

### 選択肢の比較

#### 選択肢1: 各WebSocketハンドラーで独自管理（現状維持）

**メリット**:
- 変更不要
- 各ハンドラーが独立

**デメリット**:
- 実装の重複
- イベントハンドラー重複登録の問題が継続
- メモリリーク
- コードの保守性が低い

#### 選択肢2: ConnectionManagerを拡張（選択）

**メリット**:
- コードの一元化・再利用
- イベントハンドラー重複登録の防止
- メモリリーク解消
- 既存のSession WebSocketの実装を参考にできる
- 将来的な拡張が容易

**デメリット**:
- 既存のClaude/Terminal WebSocketハンドラーの変更が必要
- テストの追加が必要

#### 選択肢3: 完全な再設計（新しいWebSocket管理層を作成）

**メリット**:
- 最適な設計を実現可能
- 既存コードの制約を受けない

**デメリット**:
- 実装コストが高い
- 既存の動作するSession WebSocketも変更が必要
- リスクが高い

### 決定の理由

**選択肢2（ConnectionManagerの拡張）を選択した理由**:

1. **既存の実装を活用**: Session WebSocketで既に動作している実装をベースにできる
2. **段階的な移行**: Session WebSocketは変更せず、Claude/Terminal WebSocketのみ変更
3. **リスクの最小化**: 既に動作している部分に手を加えない
4. **開発コストの適正化**: 完全な再設計よりもコストが低い
5. **将来の拡張性**: 統一されたインターフェースで新しいWebSocketタイプの追加が容易

## 影響

### 変更が必要なコンポーネント

1. **src/lib/websocket/connection-manager.ts**: 新機能の追加
   - `broadcast()`メソッド
   - `registerHandler()`/`unregisterHandler()`メソッド
   - スクロールバックバッファ管理

2. **src/lib/websocket/claude-ws.ts**: ConnectionManager使用に変更
   - `activeConnections` Mapの削除
   - ConnectionManager経由での接続管理

3. **src/lib/websocket/terminal-ws.ts**: ConnectionManager使用に変更
   - `activeConnections` Mapの削除
   - ConnectionManager経由での接続管理

### 影響を受けるが変更不要

- **src/lib/websocket/session-ws.ts**: 既にConnectionManagerを使用（参考実装）
- **src/lib/websocket/scrollback-buffer.ts**: 既存実装を再利用

### テスト要件

- ConnectionManagerの単体テスト（新機能）
- Claude/Terminal WebSocketの統合テスト
- 複数ブラウザでの同時接続E2Eテスト

## 実装計画

### Phase 1: ConnectionManagerの拡張

1. 新しいメソッドの追加（後方互換性を維持）
2. 単体テストの作成
3. 既存のSession WebSocketで動作確認

### Phase 2: Claude WebSocketの移行

1. ConnectionManager使用に変更
2. テストの追加
3. 統合テスト

### Phase 3: Terminal WebSocketの移行

1. ConnectionManager使用に変更
2. テストの追加
3. 統合テスト

### Phase 4: E2Eテスト

1. 複数ブラウザでの同時接続テスト
2. イベントハンドラー重複登録のテスト
3. メモリリークテスト

## 代替案の記録

### 代替案A: gRPC/WebRTC使用

WebSocketの代わりにgRPCやWebRTCを使用する案も検討しましたが、以下の理由で却下：

- 既存のWebSocket実装が安定している
- クライアント側の変更が大きい
- ブラウザサポートの問題（特にWebRTC）
- 開発コストが非常に高い

### 代替案B: Redis Pub/Subでブロードキャスト

複数サーバー間でのブロードキャストにRedis Pub/Subを使用する案も検討しましたが、現時点では却下：

- 現在は単一サーバーで動作
- Redisの追加インフラが必要
- 将来的な拡張として検討可能（スケールアウト時）

## 参照

- [要件定義: US-001](../../requirements/stories/US-001.md) @../../requirements/stories/US-001.md
- [ConnectionManager設計](../components/connection-manager.md) @../components/connection-manager.md
- [既存実装: Session WebSocket](../../../src/lib/websocket/session-ws.ts) @../../../src/lib/websocket/session-ws.ts

## 変更履歴

| 日付 | 変更内容 | 承認者 |
|-----|---------|--------|
| 2026-02-11 | 初版作成 | Claude |

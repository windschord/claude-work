# DEC-004: 状態永続化の戦略

## ステータス

**承認済**

## コンテキスト

サーバー再起動時にセッション状態（接続数、タイマー、ステータス）がメモリから失われる問題を解決する必要があります。

## 決定事項

**セッション状態をPrisma/SQLiteデータベースに永続化し、サーバー起動時に復元する**

### 永続化する情報

- `active_connections`: アクティブな接続数
- `destroy_at`: 自動破棄予定時刻
- `last_active_at`: 最終アクティブ時刻
- `status`: セッション状態（ACTIVE, IDLE, ERROR, TERMINATED）
- `container_id`: Docker環境のコンテナID（既存）

## 根拠

### 選択肢の比較

| 選択肢 | メリット | デメリット | 選択 |
|-------|---------|-----------|------|
| データベース永続化 | 信頼性高、復元容易 | DB書き込みオーバーヘッド | ✓ |
| ファイル永続化 | シンプル | 並行アクセス制御が困難 | - |
| Redisキャッシュ | 高速 | 追加インフラ、永続性低 | - |
| メモリのみ（現状） | 高速 | 再起動時に失われる | - |

### 決定の理由

1. **既存のPrismaインフラを活用**: 追加インフラ不要
2. **信頼性**: SQLiteの永続性を活用
3. **復元の容易性**: サーバー起動時にクエリで取得
4. **トランザクション**: データ整合性を保証

## 実装戦略

### 非同期更新

頻繁に更新される`last_active_at`は非同期で更新し、パフォーマンスへの影響を最小化：

```typescript
// 待機せず、エラーも無視
updateLastActiveTime(sessionId).catch(error => {
  logger.error('Failed to update last_active_at:', error)
})
```

### 状態復元

```typescript
async function restoreSessionsOnStartup(): Promise<void> {
  const sessions = await prisma.session.findMany({
    where: { status: { in: ['ACTIVE', 'IDLE'] } }
  })

  for (const session of sessions) {
    await ptySessionManager.restoreSession(session)
  }
}
```

## 参照

- [要件定義: US-004](../../requirements/stories/US-004.md) @../../requirements/stories/US-004.md
- [データベーススキーマ](../database/schema.md) @../database/schema.md

## 変更履歴

| 日付 | 変更内容 | 承認者 |
|-----|---------|--------|
| 2026-02-11 | 初版作成 | Claude |

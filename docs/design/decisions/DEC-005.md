# DEC-005: Docker起動待機メカニズム

## ステータス

**承認済**

## コンテキスト

Dockerコンテナ起動直後はコンテナ内のプロセスが完全に準備できておらず、以下の問題が発生：

1. リサイズコマンドが無効化される
2. PTY execが失敗する
3. 初回プロンプト表示まで数秒かかる

## 決定事項

**コンテナが完全に起動するまで待機する`waitForContainerReady()`メソッドを実装する**

### 待機戦略

1. **docker inspect**でコンテナのRunning状態を確認
2. **docker exec**でヘルスチェックコマンドを実行
3. **最大30秒のタイムアウト**で失敗時はエラー
4. **1秒間隔でリトライ**

## 根拠

### 選択肢の比較

| 選択肢 | メリット | デメリット | 選択 |
|-------|---------|-----------|------|
| 起動待機（ポーリング） | 確実、シンプル | リトライのオーバーヘッド | ✓ |
| 固定sleep | 実装簡単 | 無駄な待機、不確実 | - |
| ヘルスチェックエンドポイント | 正確 | コンテナイメージ変更必要 | - |
| 待機なし（現状） | 最速 | 問題が発生 | - |

### 決定の理由

1. **確実性**: コンテナが本当に準備完了するまで待機
2. **シンプル**: 既存のDocker CLIを使用
3. **柔軟性**: タイムアウトとリトライ間隔を調整可能
4. **コンテナイメージ非依存**: イメージ変更不要

## 実装

```typescript
private async waitForContainerReady(containerId: string): Promise<void> {
  const maxRetries = 30
  const retryInterval = 1000 // 1秒

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      // コンテナ状態確認
      const { stdout } = await execAsync(
        `docker inspect --format='{{.State.Running}}' ${containerId}`
      )

      if (stdout.trim() === 'true') {
        // ヘルスチェック
        await execAsync(`docker exec ${containerId} echo "health-check"`, {
          timeout: 2000
        })

        logger.info(`Container ${containerId} ready after ${attempt} attempts`)
        return
      }
    } catch (error) {
      logger.debug(`Container not ready, retry ${attempt}/${maxRetries}`)
    }

    await new Promise(resolve => setTimeout(resolve, retryInterval))
  }

  throw new Error(`Container ${containerId} failed to start within timeout`)
}
```

## パフォーマンスへの影響

- **通常起動**: 3-5秒（イメージ既存）
- **初回起動**: 20-30秒（イメージpull含む）
- **NFR-PERF-004要件**: 30秒以内（Docker環境）

## 参照

- [要件定義: US-003](../../requirements/stories/US-003.md) @../../requirements/stories/US-003.md
- [DockerAdapter設計](../components/docker-adapter.md) @../components/docker-adapter.md

## 変更履歴

| 日付 | 変更内容 | 承認者 |
|-----|---------|--------|
| 2026-02-11 | 初版作成 | Claude |

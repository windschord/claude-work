# DEC-003: イベントハンドラーの登録戦略

## ステータス

**承認済**

## コンテキスト

現在の実装では、各WebSocket接続が確立されるたびに、PTYのイベントハンドラー（`onData`, `onExit`）を登録しています。これにより、以下の問題が発生しています：

1. **イベントハンドラーの重複登録**: 5つのブラウザから接続すると、5つのハンドラーが登録される
2. **データの重複送信**: 同じデータが5回送信される
3. **メモリリーク**: 接続が切断されてもハンドラーが残留
4. **パフォーマンス低下**: ハンドラー数に比例して処理時間が増加

### 現在の問題のある実装

```typescript
// claude-ws.ts（現在の問題のある実装）
function handleConnection(ws: WebSocket, sessionId: string) {
  const pty = ptyManager.getPTY(sessionId)

  // 問題: 接続ごとにハンドラーを登録
  pty.onData((data) => {
    ws.send(data) // 接続ごとに送信
  })

  pty.onExit((exitCode) => {
    ws.close()
  })
}
```

## 決定事項

**PTYのイベントハンドラーはセッション単位で1つのみ登録し、ブロードキャストで全接続に配信する**

### 実装戦略

1. **PTYセッション作成時にハンドラー登録**: 1セッションにつき1回のみ
2. **ブロードキャスト配信**: ConnectionManager経由で全接続へ送信
3. **最後の接続が切断されたらハンドラー削除**: リソースの適切なクリーンアップ

### アーキテクチャ

```text
[PTYセッション]
    |
    +-- onData ハンドラー（1つ）
    |       |
    |       v
    |   [ConnectionManager.broadcast()]
    |       |
    |       +----> [WebSocket 1]
    |       +----> [WebSocket 2]
    |       +----> [WebSocket 3]
    |
    +-- onExit ハンドラー（1つ）
```

## 根拠

### 選択肢の比較

#### 選択肢1: 接続ごとにハンドラー登録（現状）

**メリット**:
- 実装がシンプル
- 各接続が独立

**デメリット**:
- イベントハンドラーの重複登録
- データの重複送信
- メモリリーク
- パフォーマンス低下（接続数に比例）

#### 選択肢2: セッション単位でハンドラー登録（選択）

**メリット**:
- イベントハンドラーが1つのみ
- データの重複送信なし
- メモリリークの防止
- パフォーマンスが接続数に依存しない（ブロードキャストのみ）

**デメリット**:
- 実装がやや複雑
- ConnectionManagerとの統合が必要

#### 選択肢3: EventEmitterでラップ

PTYをEventEmitterでラップして、接続管理とイベント管理を分離する案。

**メリット**:
- 柔軟なイベント管理
- 複数のリスナーを制御可能

**デメリット**:
- 追加の抽象化層
- 実装の複雑性が増加
- 選択肢2で十分対応可能

### 決定の理由

**選択肢2（セッション単位でハンドラー登録）を選択した理由**:

1. **根本的な問題解決**: イベントハンドラー重複登録の問題を根本から解決
2. **パフォーマンス向上**: ハンドラー数が接続数に依存しない
3. **メモリ効率**: ハンドラー数を最小限に抑える
4. **設計の明確性**: 1セッション1ハンドラーというシンプルなルール

## 実装の詳細

### PTYSessionManagerでのハンドラー登録

```typescript
class PTYSessionManager {
  async createSession(options: SessionOptions): Promise<PTYSession> {
    // PTY作成
    const pty = await adapter.spawn(options)

    // セッション単位でハンドラーを登録（1回のみ）
    this.registerPTYHandlers(sessionId, pty)

    return session
  }

  private registerPTYHandlers(sessionId: string, pty: IPty): void {
    // データハンドラー（1つ）
    const dataHandler = (data: string) => {
      this.handlePTYData(sessionId, data)
    }

    // 終了ハンドラー（1つ）
    const exitHandler = (exitCode: { exitCode: number }) => {
      this.handlePTYExit(sessionId, exitCode.exitCode)
    }

    // ハンドラーを登録
    pty.onData(dataHandler)
    pty.onExit(exitHandler)

    // ConnectionManagerに記録（後でクリーンアップするため）
    this.connectionManager.registerHandler(sessionId, 'data', dataHandler)
    this.connectionManager.registerHandler(sessionId, 'exit', exitHandler)
  }

  private handlePTYData(sessionId: string, data: string): void {
    // スクロールバックバッファに追加
    const buffer = this.connectionManager.getScrollbackBuffer(sessionId)
    buffer?.append(data)

    // 全接続にブロードキャスト
    this.connectionManager.broadcast(sessionId, data)
  }
}
```

### ConnectionManagerでのハンドラー管理

```typescript
class ConnectionManager {
  // ハンドラー登録情報を保持
  private eventHandlers: Map<string, Map<string, Function>> = new Map()

  registerHandler(sessionId: string, eventName: string, handler: Function): void {
    if (!this.eventHandlers.has(sessionId)) {
      this.eventHandlers.set(sessionId, new Map())
    }

    const handlers = this.eventHandlers.get(sessionId)!

    // 既存のハンドラーがあれば警告
    if (handlers.has(eventName)) {
      logger.warn(`Handler for ${eventName} already registered, overwriting`)
    }

    handlers.set(eventName, handler)
  }

  unregisterHandler(sessionId: string, eventName: string): void {
    const handlers = this.eventHandlers.get(sessionId)
    handlers?.delete(eventName)

    if (handlers?.size === 0) {
      this.eventHandlers.delete(sessionId)
    }
  }

  cleanup(sessionId: string): void {
    // ハンドラーを削除
    this.eventHandlers.delete(sessionId)
    // その他のクリーンアップ
  }
}
```

## パフォーマンスへの影響

### 現在の実装（接続ごと）

```text
接続数: 5
ハンドラー数: 5（データ） + 5（終了） = 10
データ送信回数: 5回（重複）

処理時間: O(N) × N = O(N²)
  - Nハンドラーが実行される
  - 各ハンドラーが1接続に送信
```

### 新しい実装（セッション単位）

```text
接続数: 5
ハンドラー数: 1（データ） + 1（終了） = 2
データ送信回数: 5回（ブロードキャスト）

処理時間: O(1) + O(N) = O(N)
  - 1ハンドラーが実行
  - ブロードキャストでN接続に送信
```

### パフォーマンス改善

- **ハンドラー数**: 10 → 2（80%削減）
- **処理時間**: O(N²) → O(N)（接続数5の場合、理論上5倍高速化）
- **メモリ使用量**: ハンドラー数に比例して削減

## テスト戦略

### ハンドラー登録のテスト

```typescript
describe('PTY Event Handler Registration', () => {
  it('should register only one handler per session', async () => {
    const manager = PTYSessionManager.getInstance()
    const session = await manager.createSession(options)

    // ハンドラーが1つだけ登録されているか確認
    expect(manager.hasHandler(session.id, 'data')).toBe(true)
    expect(manager.hasHandler(session.id, 'exit')).toBe(true)

    // 複数接続を追加しても、ハンドラーは増えない
    manager.addConnection(session.id, ws1)
    manager.addConnection(session.id, ws2)

    // 依然として1つのみ
    expect(manager.getHandlerCount(session.id)).toBe(2) // data + exit
  })
})
```

### ブロードキャストのテスト

```typescript
describe('PTY Data Broadcasting', () => {
  it('should broadcast data to all connections', async () => {
    const manager = PTYSessionManager.getInstance()
    const session = await manager.createSession(options)

    const ws1 = createMockWebSocket()
    const ws2 = createMockWebSocket()

    manager.addConnection(session.id, ws1)
    manager.addConnection(session.id, ws2)

    // PTYからデータを送信
    simulatePTYData(session.id, 'test output')

    // すべての接続が受信
    expect(ws1.send).toHaveBeenCalledWith('test output')
    expect(ws2.send).toHaveBeenCalledWith('test output')

    // 送信回数は各接続1回のみ
    expect(ws1.send).toHaveBeenCalledTimes(1)
    expect(ws2.send).toHaveBeenCalledTimes(1)
  })
})
```

## 影響

### 肯定的影響

- イベントハンドラー重複登録の解消
- パフォーマンスの大幅な改善（O(N²) → O(N)）
- メモリリークの防止
- データ重複送信の解消
- ブラウザごとの表示不整合の解消

### 潜在的リスク

- 実装の複雑性がやや増加（対策: 明確な設計文書）
- ConnectionManagerとの密結合（対策: インターフェース定義）

## 検証基準

1. **機能**: 複数ブラウザで同一のターミナル内容が表示される
2. **パフォーマンス**: メッセージ配信遅延 < 100ms（NFR-PERF-001）
3. **メモリ**: 接続切断後にハンドラーが削除される
4. **信頼性**: 24時間稼働でメモリリークが発生しない

## 参照

- [要件定義: US-001](../../requirements/stories/US-001.md) @../../requirements/stories/US-001.md
- [ConnectionManager設計](../components/connection-manager.md) @../components/connection-manager.md
- [PTYSessionManager設計](../components/pty-session-manager.md) @../components/pty-session-manager.md
- [設計決定: DEC-001](DEC-001.md) @DEC-001.md

## 変更履歴

| 日付 | 変更内容 | 承認者 |
|-----|---------|--------|
| 2026-02-11 | 初版作成 | Claude |

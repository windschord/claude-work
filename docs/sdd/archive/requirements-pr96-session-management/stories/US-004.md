# US-004: 状態管理の統一

## ユーザーストーリー

**As a** システム管理者
**I want** サーバー再起動後もセッション状態が維持される
**So that** システムの信頼性が向上し、予期しないダウンタイムからの復旧が容易になる

## 背景

### 現状の問題
現在、セッション状態がメモリとデータベースに分散して管理されています：

**メモリ上の状態**:
- `activeConnections`: アクティブなWebSocket接続数
- `creatingSessionPromises`: セッション作成中のPromise
- `destroyTimers`: セッション自動破棄タイマー

**データベース上の状態**:
- セッションメタデータ（project_id, branch_name, worktree_path等）
- `container_id`: Docker環境のコンテナID

この分散により：
1. **サーバー再起動時の状態喪失**: メモリ上の状態が失われる
2. **状態不整合**: メモリとDBで状態が一致しない
3. **復旧の困難**: タイマーや接続数が復元できない
4. **デバッグの困難**: 状態がどこにあるか追跡が難しい

### US-002との関係
US-002でPTYSessionManagerが導入され、セッション管理が一元化されました。本USでは、そのセッション状態をデータベースに永続化し、サーバー再起動時に復元します。

## 受入基準（EARS記法）

### 機能要件

#### REQ-004-001: セッション状態の記録
- セッションの状態が変化した時、システムはデータベースに状態を記録しなければならない

#### REQ-004-002: 接続数の永続化
- WebSocket接続が確立または切断された時、システムはアクティブ接続数をデータベースに記録しなければならない

#### REQ-004-003: タイマー情報の永続化
- セッション自動破棄タイマーが設定された時、システムはタイマー情報（期限時刻）をデータベースに記録しなければならない

#### REQ-004-004: 状態の復元
- サーバーが起動した時、システムはデータベースから既存セッションの状態を読み込み、PTYSessionManagerに復元しなければならない

#### REQ-004-005: タイマーの再設定
- サーバーが起動した時、システムは永続化されたタイマー情報からタイマーを再設定しなければならない

#### REQ-004-006: 孤立セッションの検出
- サーバー起動時、システムは孤立したセッション（PTYが存在しないセッション）を検出しなければならない

#### REQ-004-007: 孤立セッションのクリーンアップ
- 孤立セッションが検出された時、システムは当該セッションをクリーンアップしなければならない

#### REQ-004-008: 状態遷移のログ
- セッション状態が変化した時、システムは状態遷移をログに記録しなければならない

### 非機能要件

#### NFR-004-001: 復元時間
- サーバー起動時、システムは10秒以内にセッション状態を復元しなければならない

#### NFR-004-002: データ整合性
- 状態更新時、システムはトランザクションを使用してデータ整合性を保証しなければならない

#### NFR-004-003: パフォーマンス
- 状態更新の頻度が高くてもシステムパフォーマンスが10%以上低下してはならない

## テストシナリオ

### シナリオ1: サーバー再起動後のセッション復元
**Given**: 3つのセッションが実行中
**When**: サーバーを再起動する
**Then**:
- データベースから3つのセッション情報が読み込まれる
- PTYSessionManagerにセッションが復元される
- 接続数とタイマー情報が復元される

### シナリオ2: 状態の永続化
**Given**: セッションが作成されている
**When**: WebSocket接続が確立または切断される
**Then**:
- データベースのアクティブ接続数が更新される
- 状態変更がログに記録される

### シナリオ3: タイマーの再設定
**Given**: セッションに30分の自動破棄タイマーが設定されている
**When**: 15分後にサーバーを再起動する
**Then**:
- タイマーが再設定される
- 残り15分後にセッションが自動破棄される

### シナリオ4: 孤立セッションのクリーンアップ
**Given**: サーバーが異常終了し、PTYプロセスが終了している
**When**: サーバーを再起動する
**Then**:
- 孤立セッションが検出される
- 孤立セッションがデータベースから削除される
- Worktreeが削除される（設定による）

### シナリオ5: 状態不整合の検出
**Given**: データベースとメモリの状態が不一致
**When**: 状態チェックが実行される
**Then**:
- 不整合が検出される
- 警告がログに記録される
- 自動修正が試行される（可能な場合）

## 影響を受けるコンポーネント

### 修正が必要なファイル
1. **prisma/schema.prisma**
   - セッション状態フィールドの追加：
     - `active_connections`: アクティブな接続数
     - `destroy_at`: 自動破棄予定時刻
     - `last_active_at`: 最終アクティブ時刻
     - `status`: セッション状態（ACTIVE, IDLE, ERROR等）

2. **src/services/pty-session-manager.ts**
   - 状態変更時のDB更新
   - サーバー起動時の状態復元
   - タイマー再設定ロジック

3. **src/lib/websocket/claude-ws.ts**
   - 接続確立時の状態更新
   - 接続切断時の状態更新

4. **src/lib/websocket/terminal-ws.ts**
   - 接続確立時の状態更新
   - 接続切断時の状態更新

5. **server.ts**
   - サーバー起動時の状態復元処理の追加

### 影響を受けるが修正不要なファイル
- **src/lib/db.ts**: Prismaクライアントの再生成のみ

## 依存関係

### 前提条件
- US-002: PTYセッションマネージャーの導入（完了必須）

### 後続タスク
- なし（最終ステップ）

### 並行可能なタスク
- US-003: Docker環境の安定化（並行実装可能）

## 実装のガイドライン

### データベーススキーマの拡張
```prisma
model Session {
  id                String   @id @default(uuid())
  project_id        String
  branch_name       String
  worktree_path     String
  environment_id    String
  container_id      String?
  active_connections Int     @default(0)
  destroy_at        DateTime?
  last_active_at    DateTime @default(now())
  status            SessionStatus @default(ACTIVE)
  created_at        DateTime @default(now())
  updated_at        DateTime @updatedAt

  project           Project  @relation(fields: [project_id], references: [id], onDelete: Cascade)
  environment       ExecutionEnvironment @relation(fields: [environment_id], references: [id])
  messages          Message[]
}

enum SessionStatus {
  ACTIVE
  IDLE
  ERROR
  TERMINATED
}
```

### 状態復元の実装
```typescript
async function restoreSessionsOnStartup(): Promise<void> {
  const sessions = await prisma.session.findMany({
    where: { status: { in: ['ACTIVE', 'IDLE'] } }
  })

  for (const session of sessions) {
    try {
      // PTYが存在するか確認
      const ptyExists = await checkPTYExists(session.id)

      if (ptyExists) {
        // PTYSessionManagerに復元
        await ptySessionManager.restoreSession(session)

        // タイマー再設定
        if (session.destroy_at) {
          await ptySessionManager.setDestroyTimer(session.id, session.destroy_at)
        }
      } else {
        // 孤立セッション
        logger.warn(`Orphaned session detected: ${session.id}`)
        await cleanupOrphanedSession(session)
      }
    } catch (error) {
      logger.error(`Failed to restore session ${session.id}:`, error)
      await markSessionAsError(session.id)
    }
  }
}
```

### 状態更新の実装
```typescript
async function updateSessionState(
  sessionId: string,
  updates: Partial<SessionState>
): Promise<void> {
  await prisma.session.update({
    where: { id: sessionId },
    data: {
      ...updates,
      updated_at: new Date()
    }
  })

  logger.debug(`Session ${sessionId} state updated:`, updates)
}
```

### 主要な設計決定
1. **楽観的更新**: 状態更新は非同期で実行（UI応答性を優先）
2. **定期的な状態同期**: 5分ごとにメモリとDBの状態を同期
3. **エラー時のフォールバック**: 復元失敗時は孤立セッションとしてクリーンアップ
4. **ステータスの定義**:
   - `ACTIVE`: 接続あり、アクティブ
   - `IDLE`: 接続なし、タイマー設定中
   - `ERROR`: エラー状態
   - `TERMINATED`: 終了済み

### 実装の順序
1. データベーススキーマの拡張
2. `npx prisma db push` でスキーマ適用
3. `npx prisma generate` でクライアント生成
4. PTYSessionManagerに状態更新ロジック追加
5. サーバー起動時の復元処理実装
6. WebSocketハンドラーの状態更新追加
7. 孤立セッションクリーンアップ実装
8. 単体テストの作成
9. 統合テストの作成
10. サーバー再起動テスト

## 検証方法

### 単体テスト
- [ ] 状態更新がデータベースに記録される
- [ ] 状態復元が正しく動作する
- [ ] タイマー再設定が正しく動作する
- [ ] 孤立セッション検出が正しく動作する
- [ ] エラーハンドリングが正しく動作する

### 統合テスト
- [ ] サーバー再起動後のセッション復元が正しく動作する
- [ ] 状態の永続化と復元が正しく動作する
- [ ] タイマーが正しく再設定される

### E2Eテスト（Playwright）
- [ ] サーバー再起動後にセッションに再接続できる
- [ ] タイマーが正しく再設定され、セッションが自動破棄される
- [ ] 孤立セッションが適切にクリーンアップされる

### サーバー再起動テスト
- [ ] 正常再起動時の状態復元
- [ ] 異常終了後の復旧
- [ ] 複数セッション実行中の再起動
- [ ] タイマー設定中の再起動

## リスク

| リスク | 影響度 | 対策 |
|-------|--------|------|
| データベーススキーマ変更の影響 | 中 | マイグレーション計画、後方互換性の考慮 |
| パフォーマンスへの影響 | 中 | 非同期更新、バッチ処理、インデックス最適化 |
| 状態不整合 | 中 | トランザクション使用、定期同期 |
| 復元失敗 | 低 | エラーハンドリング、フォールバック処理 |

## 見積もり

- **設計**: 4時間
- **スキーマ変更**: 2時間
- **実装**: 12時間
- **テスト**: 8時間
- **合計**: 26時間（3-4日）

## 参照

- 元の実装計画: セッション管理の包括的改善計画 - ステップ4
- 依存US: US-002（PTYセッションマネージャーの導入）
- 既存実装:
  - prisma/schema.prisma
  - src/services/pty-session-manager.ts（US-002で作成）
  - server.ts

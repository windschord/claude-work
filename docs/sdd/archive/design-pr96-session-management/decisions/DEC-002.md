# DEC-002: PTYSessionManagerのシングルトンパターン

## ステータス

**承認済**

## コンテキスト

PTYSessionManagerは、アプリケーション全体でPTYセッションを統合管理する新しいコンポーネントです。以下の設計パターンを検討しました：

1. **シングルトンパターン**: アプリケーション全体で1つのインスタンス
2. **依存性注入（DI）**: 各コンポーネントにインスタンスを注入
3. **静的クラス**: すべてのメソッドをstaticに
4. **ファクトリーパターン**: 必要に応じてインスタンスを生成

## 決定事項

**PTYSessionManagerはシングルトンパターンで実装する**

```typescript
export class PTYSessionManager extends EventEmitter {
  private static instance: PTYSessionManager

  private constructor() {
    super()
    // 初期化処理
  }

  public static getInstance(): PTYSessionManager {
    if (!PTYSessionManager.instance) {
      PTYSessionManager.instance = new PTYSessionManager()
    }
    return PTYSessionManager.instance
  }
}
```

## 根拠

### 選択肢の比較

#### 選択肢1: シングルトンパターン（選択）

**メリット**:
- グローバルなアクセスポイント
- インスタンスの一意性が保証される
- セッション状態の一元管理
- 既存のAdapterFactoryと統一したパターン
- テストでのリセットが可能

**デメリット**:
- グローバル状態（ただし、セッション管理の性質上、これは利点でもある）
- テストでのモック化にやや工夫が必要

#### 選択肢2: 依存性注入（DI）

**メリット**:
- テストでのモック化が容易
- 依存関係が明示的

**デメリット**:
- DIコンテナの導入が必要
- すべてのコンポーネントにインスタンスを渡す必要がある
- Next.jsのサーバーコンポーネントとの統合が複雑
- 既存のコードベースとのパターン不一致

#### 選択肢3: 静的クラス

**メリット**:
- インスタンス化不要
- シンプル

**デメリット**:
- EventEmitterを継承できない
- ライフサイクル管理が困難
- テストでのリセットが困難
- 状態を持つクラスには不適切

#### 選択肢4: ファクトリーパターン

**メリット**:
- 柔軟なインスタンス生成

**デメリット**:
- 複数のインスタンスが作成される可能性
- セッション状態が分散する
- グローバルなセッション管理という要件に合わない

### 決定の理由

**シングルトンパターンを選択した理由**:

1. **セッション管理の性質**: セッション状態はアプリケーション全体で一元管理されるべき
2. **既存パターンとの統一**: AdapterFactoryも同じパターンを使用
3. **グローバルアクセス**: WebSocketハンドラー、APIルート、サーバー起動処理など、複数の場所からアクセス
4. **インスタンスの一意性**: 複数のインスタンスが存在するとセッション状態が分散する
5. **EventEmitterとの互換性**: EventEmitterを継承でき、ライフサイクルイベントを発火できる

## 実装の詳細

### シングルトンの実装

```typescript
export class PTYSessionManager extends EventEmitter implements IPTYSessionManager {
  private static instance: PTYSessionManager
  private sessions: Map<string, PTYSession> = new Map()
  private connectionManager: ConnectionManager
  private adapterFactory: AdapterFactory
  private prisma: PrismaClient

  private constructor() {
    super()
    this.connectionManager = ConnectionManager.getInstance()
    this.adapterFactory = AdapterFactory.getInstance()
    this.prisma = db
  }

  public static getInstance(): PTYSessionManager {
    if (!PTYSessionManager.instance) {
      PTYSessionManager.instance = new PTYSessionManager()
    }
    return PTYSessionManager.instance
  }

  // テスト用のリセットメソッド（プロダクションでは使用しない）
  public static resetInstance(): void {
    if (process.env.NODE_ENV === 'test') {
      PTYSessionManager.instance = undefined as any
    }
  }
}
```

### 使用例

```typescript
// WebSocketハンドラーから
const sessionManager = PTYSessionManager.getInstance()
const session = sessionManager.getSession(sessionId)

// APIルートから
const sessionManager = PTYSessionManager.getInstance()
await sessionManager.createSession(options)

// サーバー起動処理から
const sessionManager = PTYSessionManager.getInstance()
await sessionManager.restoreSessionsOnStartup()
```

## テスト戦略

### シングルトンのテスト

```typescript
describe('PTYSessionManager', () => {
  afterEach(() => {
    // テスト後にインスタンスをリセット
    PTYSessionManager.resetInstance()
  })

  it('should return the same instance', () => {
    const instance1 = PTYSessionManager.getInstance()
    const instance2 = PTYSessionManager.getInstance()

    expect(instance1).toBe(instance2)
  })

  it('should reset instance for testing', () => {
    const instance1 = PTYSessionManager.getInstance()
    PTYSessionManager.resetInstance()
    const instance2 = PTYSessionManager.getInstance()

    expect(instance1).not.toBe(instance2)
  })
})
```

### モック化の戦略

```typescript
// 必要に応じてメソッドをモック化
jest.spyOn(PTYSessionManager.getInstance(), 'createSession')
  .mockResolvedValue(mockSession)
```

## セキュリティ考慮事項

### インスタンスの保護

```typescript
private constructor() {
  // privateコンストラクタで外部からのインスタンス化を防止
}

public static getInstance(): PTYSessionManager {
  // getInstance()メソッドのみでアクセス可能
}
```

### 並行アクセスの安全性

シングルトンパターン自体は並行アクセスに対して安全ですが、内部の状態（`sessions` Map）へのアクセスは適切に管理する必要があります。

```typescript
// 例: セッション作成の原子性
async createSession(options: SessionOptions): Promise<PTYSession> {
  // 既存セッションのチェック（競合防止）
  if (this.sessions.has(sessionId)) {
    throw new Error(`Session ${sessionId} already exists`)
  }

  // セッション作成
  // ...
}
```

## 影響

### 肯定的影響

- セッション状態の一元管理
- コードの簡潔性（DI不要）
- 既存パターン（AdapterFactory）との統一
- グローバルアクセスの容易性

### 潜在的リスク

- テストでのモック化がやや複雑（対策: resetInstance()メソッド）
- グローバル状態の管理（対策: 明確な責務の定義）

## 代替案の記録

### 代替案A: DIコンテナ（TypeDI等）

TypeDIやInversifyを使用したDIパターンも検討しましたが、以下の理由で却下：

- 既存のコードベースがDIを使用していない
- Next.jsとの統合が複雑
- 学習コストと導入コストが高い
- シンプルさの喪失

### 代替案B: Reactコンテキスト

Reactコンテキストを使用してクライアント側で管理する案も検討しましたが、以下の理由で却下：

- PTYセッションはサーバー側で管理されるべき
- クライアント側での管理は不適切
- セキュリティリスク

## 参照

- [要件定義: US-002](../../requirements/stories/US-002.md) @../../requirements/stories/US-002.md
- [PTYSessionManager設計](../components/pty-session-manager.md) @../components/pty-session-manager.md
- [既存実装: AdapterFactory](../../../src/services/adapter-factory.ts) @../../../src/services/adapter-factory.ts

## 変更履歴

| 日付 | 変更内容 | 承認者 |
|-----|---------|--------|
| 2026-02-11 | 初版作成 | Claude |

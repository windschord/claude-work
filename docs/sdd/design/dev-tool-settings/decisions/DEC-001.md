# DEC-001: 暗号化ライブラリの選択

## ステータス

**ステータス**: 承認済
**決定日**: 2024-01-15
**レビュアー**: システムアーキテクト

## コンテキスト

SSH秘密鍵をデータベースに保存する際、セキュリティを確保するために暗号化が必須です。Node.js環境で利用可能な暗号化ライブラリの中から、最適なものを選定する必要があります。

### 現状の課題
- SSH秘密鍵を平文でデータベースに保存することはセキュリティリスクが高い
- 暗号化処理は性能とセキュリティのバランスが重要
- 依存ライブラリの追加は保守コストが増加する

### 制約条件
- Node.js環境で動作すること
- AES-256-GCM アルゴリズムをサポートすること
- メンテナンスされているライブラリであること
- 既存システムとの互換性があること

## 情報の明確性

### 明示された情報
- 暗号化アルゴリズム: AES-256-GCM
- マスターキー管理: 環境変数
- 既存技術スタック: Node.js, TypeScript

### 不明/要確認の情報

なし（すべて確認済み）

### 確認状況
- [x] ユーザー確認済み

---

## 検討した選択肢

### 選択肢A: Node.js 標準 crypto モジュール（採用）

**概要**: Node.js に標準搭載されている crypto モジュールを使用

**メリット**:
- **外部依存なし**: 追加のライブラリインストール不要
- **高性能**: ネイティブC++実装で高速
- **安定性**: Node.js のコアモジュールとして長期サポート
- **学習コスト低**: 広く使われており、ドキュメントが豊富
- **保守コスト低**: Node.js のアップデートに追従するだけ

**デメリット**:
- 特になし（標準ライブラリとして十分な機能を提供）

**コスト/工数**: 追加コストなし

**実装例**:
```typescript
import { createCipheriv, createDecipheriv, randomBytes } from 'crypto';

// 暗号化鍵: ENCRYPTION_KEY 環境変数からbase64デコード（32バイト必須）
const key = Buffer.from(process.env.ENCRYPTION_KEY!, 'base64');
if (key.length !== 32) {
  throw new Error(`Invalid ENCRYPTION_KEY length: expected 32 bytes, got ${key.length} bytes.`);
}
const algorithm = 'aes-256-gcm';
const iv = randomBytes(16);

// 暗号化
const cipher = createCipheriv(algorithm, key, iv);
let encrypted = cipher.update(plaintext, 'utf8', 'base64');
encrypted += cipher.final('base64');
const authTag = cipher.getAuthTag();
const result = `${iv.toString('base64')}:${authTag.toString('base64')}:${encrypted}`;

// 復号化
const [ivPart, authTagPart, encPart] = result.split(':');
const decipher = createDecipheriv(algorithm, key, Buffer.from(ivPart, 'base64'));
decipher.setAuthTag(Buffer.from(authTagPart, 'base64'));
let decrypted = decipher.update(encPart, 'base64', 'utf8');
decrypted += decipher.final('utf8');
```

---

### 選択肢B: node-forge

**概要**: Pure JavaScript 実装の暗号化ライブラリ

**メリット**:
- Pure JavaScript 実装（Node.js以外の環境でも動作）
- 豊富な暗号化アルゴリズムをサポート
- ブラウザ環境でも動作可能

**デメリット**:
- **性能**: Pure JavaScriptのためネイティブ実装より遅い
- **外部依存**: 追加のライブラリインストールが必要
- **保守コスト**: ライブラリのバージョン管理が必要
- **バンドルサイズ**: ライブラリサイズが大きい（約200KB）

**コスト/工数**:
- ライブラリインストール: 5分
- 学習コスト: 1時間
- 保守コスト: 年間2-3時間（バージョンアップ対応）

---

### 選択肢C: bcrypt (不適切)

**概要**: パスワードハッシュ化ライブラリ

**メリット**:
- パスワードハッシュ化に特化
- レインボーテーブル攻撃に強い

**デメリット**:
- **用途不一致**: ハッシュ化ライブラリであり、暗号化/復号化には不向き
- **復号化不可**: ハッシュ化は一方向なので、SSH鍵を復号化できない

**コスト/工数**: 採用不可（用途不一致）

---

## 決定

**選択肢A: Node.js 標準 crypto モジュール** を採用します。

### 決定理由

1. **外部依存なし**: 追加のライブラリを導入せず、保守コストを最小化
2. **高性能**: ネイティブ実装により暗号化/復号化処理が高速
3. **安定性**: Node.js のコアモジュールとして長期サポートが保証される
4. **十分な機能**: AES-256-GCM を含む主要な暗号化アルゴリズムをサポート
5. **学習コスト低**: 既存チームメンバーが習熟している

### 実装方針

- `crypto.createCipheriv()` と `crypto.createDecipheriv()` を使用
- 暗号化鍵は環境変数 `ENCRYPTION_KEY`（Base64エンコードされた32バイト鍵）から直接取得（ハッシュ化・鍵導出は行わない）
- 鍵の生成: `openssl rand -base64 32`
- IV は各暗号化操作で `crypto.randomBytes(16)` で生成
- 保存形式: `iv:authTag:encrypted`（コロン区切り、各要素はBase64エンコード）

## 影響範囲

### 影響を受けるコンポーネント
- **EncryptionService**: crypto モジュールを使用した暗号化/復号化実装
- **SshKeyService**: EncryptionService を使用してSSH鍵を暗号化

### マイグレーション不要
新規機能のため、既存データのマイグレーションは不要

## 関連ドキュメント

- [EncryptionService](../components/encryption-service.md) @../components/encryption-service.md: 実装詳細
- [NFR-SEC-001](../../requirements/dev-tool-settings/nfr/security.md) @../../requirements/dev-tool-settings/nfr/security.md: SSH 秘密鍵の暗号化保存

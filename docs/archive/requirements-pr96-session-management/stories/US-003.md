# US-003: Docker環境の安定化

## ユーザーストーリー

**As a** 開発者
**I want** Docker環境でセッションが安定して動作する
**So that** 隔離された環境で安全に作業でき、リサイズなどの操作が正しく機能する

## 背景

### 現状の問題
Docker環境でのセッション管理に複数の問題が発生しています：

1. **Processが予期せず停止する**
   - `docker stop`がバックグラウンド実行でエラーハンドリング不完全
   - `onExit`遅延発火時に新セッションが誤って削除される可能性
   - コンテナクラッシュ時の適切な処理がない

2. **リサイズ操作が正しく動作しない**
   - コンテナ起動直後はリサイズが無効化される
   - リサイズ処理のタイミングが不適切

3. **起動の遅延**
   - コンテナ起動オーバーヘッド（初回出力まで数秒）
   - 起動完了を待機せずに処理を開始

4. **親コンテナIDの喪失**
   - 親コンテナIDがメモリ管理でサーバー再起動後に失われる
   - 孤立コンテナの管理が困難

### US-001との関係
US-001でWebSocket接続管理が統一され、Docker環境でも接続プールが正しく管理されるようになりました。本USでは、Docker環境固有の問題を解決します。

## 受入基準（EARS記法）

### 機能要件

#### REQ-003-001: コンテナ起動完了の待機
- Dockerコンテナを起動する時、システムはコンテナが完全に起動するまで待機しなければならない

#### REQ-003-002: ヘルスチェック
- コンテナ起動後、システムはコンテナの健全性を確認しなければならない

#### REQ-003-003: 同期的なコンテナ停止
- コンテナを停止する時、システムは停止完了まで待機（Promise化）しなければならない

#### REQ-003-004: エラーハンドリング
- `docker stop`がエラーを返した時、システムは適切にエラーをログに記録し、後続処理を継続しなければならない

#### REQ-003-005: 親コンテナIDの永続化
- 親コンテナIDを管理する時、システムはデータベースに永続化しなければならない

#### REQ-003-006: 孤立コンテナの検出
- サーバー起動時、システムは孤立したDockerコンテナを検出し、クリーンアップしなければならない

#### REQ-003-007: リサイズ処理の改善
- ターミナルリサイズがリクエストされた時、システムはコンテナ起動完了を確認してからリサイズを実行しなければならない

#### REQ-003-008: コンテナクラッシュの検出
- Dockerコンテナがクラッシュした時、システムはセッション状態を更新し、ユーザーに通知しなければならない

### 非機能要件

#### NFR-003-001: 起動時間
- Dockerコンテナの起動待機は、30秒以内に完了またはタイムアウトしなければならない

#### NFR-003-002: 信頼性
- `docker stop`の失敗率が5%以下でなければならない

#### NFR-003-003: 復旧性
- サーバー再起動後、システムは5分以内に孤立コンテナをクリーンアップしなければならない

## テストシナリオ

### シナリオ1: Docker環境でのセッション作成
**Given**: Docker環境が設定されている
**When**: Docker環境でセッションを作成する
**Then**:
- コンテナが正常に起動する
- 起動完了まで待機してからPTYが利用可能になる
- ヘルスチェックが成功する
- 親コンテナIDがデータベースに記録される

### シナリオ2: リサイズ操作
**Given**: Docker環境でセッションが起動している
**When**: ターミナルのサイズを変更する
**Then**:
- リサイズが正しく適用される
- コンテナ内のPTYサイズが更新される
- 表示が正しく調整される

### シナリオ3: コンテナの停止
**Given**: Docker環境でセッションが起動している
**When**: セッションを削除する
**Then**:
- `docker stop`が同期的に実行される
- 停止完了まで待機してから後続処理が実行される
- エラーが発生してもシステムがクラッシュしない

### シナリオ4: サーバー再起動後の復旧
**Given**: Docker環境でセッションが起動している
**When**: サーバーを再起動する
**Then**:
- データベースから親コンテナIDが復元される
- 孤立コンテナが検出される
- 孤立コンテナが適切にクリーンアップされる

### シナリオ5: コンテナクラッシュ
**Given**: Docker環境でセッションが起動している
**When**: コンテナが予期せずクラッシュする
**Then**:
- システムがクラッシュを検出する
- セッション状態が「エラー」に更新される
- ユーザーにエラーが通知される
- 他のセッションに影響しない

## 影響を受けるコンポーネント

### 修正が必要なファイル
1. **src/services/adapters/docker-adapter.ts**
   - コンテナ起動待機ロジックの追加
   - ヘルスチェック機能の実装
   - `docker stop`のPromise化
   - エラーハンドリングの強化
   - リサイズ処理の改善
   - コンテナクラッシュ検出

2. **prisma/schema.prisma**
   - `container_id`フィールドの永続化確認（既存）
   - 必要に応じて`parent_container_id`フィールドの追加

3. **src/services/environment-service.ts**
   - サーバー起動時の孤立コンテナクリーンアップ

### 影響を受けるが修正不要なファイル
- **src/services/adapters/host-adapter.ts**: 変更なし（Docker固有の問題）
- **src/services/adapter-factory.ts**: 変更なし

## 依存関係

### 前提条件
- US-001: WebSocket接続管理の統一（完了必須）

### 後続タスク
- なし（独立したタスク）

### 並行可能なタスク
- US-002: PTYセッションマネージャーの導入（並行実装可能だが、統合時に調整が必要）

## 実装のガイドライン

### コンテナ起動待機の実装
```typescript
async function waitForContainerReady(containerId: string): Promise<void> {
  const maxRetries = 30
  const retryInterval = 1000 // 1秒

  for (let i = 0; i < maxRetries; i++) {
    try {
      const result = await execAsync(`docker inspect --format='{{.State.Running}}' ${containerId}`)
      if (result.stdout.trim() === 'true') {
        return
      }
    } catch (error) {
      logger.warn(`Container ${containerId} not ready, retry ${i + 1}/${maxRetries}`)
    }
    await new Promise(resolve => setTimeout(resolve, retryInterval))
  }

  throw new Error(`Container ${containerId} failed to start within timeout`)
}
```

### docker stopのPromise化
```typescript
async function stopContainer(containerId: string): Promise<void> {
  try {
    await execAsync(`docker stop ${containerId}`)
    logger.info(`Container ${containerId} stopped successfully`)
  } catch (error) {
    logger.error(`Failed to stop container ${containerId}:`, error)
    // エラーを記録するが、クラッシュはしない
  }
}
```

### リサイズ処理の改善
```typescript
async function resize(rows: number, cols: number): Promise<void> {
  // コンテナ起動完了を確認
  if (!this.containerReady) {
    logger.warn('Container not ready, deferring resize')
    this.pendingResize = { rows, cols }
    return
  }

  // リサイズ実行
  this.pty.resize(cols, rows)
}
```

### 主要な設計決定
1. **起動待機のタイムアウト**: 30秒（コンテナイメージのpull時間を考慮）
2. **ヘルスチェック方法**: `docker inspect`を使用して状態確認
3. **孤立コンテナの定義**: データベースに記録されているが実行中でないコンテナ
4. **クリーンアップ戦略**: サーバー起動時とセッション作成時の二重チェック

### 実装の順序
1. コンテナ起動待機ロジックの実装
2. `docker stop`のPromise化
3. 親コンテナIDの永続化（必要に応じてスキーマ変更）
4. 孤立コンテナクリーンアップの実装
5. リサイズ処理の改善
6. コンテナクラッシュ検出の実装
7. 単体テストの作成
8. 統合テストの作成
9. E2Eテストの作成

## 検証方法

### 単体テスト
- [ ] コンテナ起動待機が正しく動作する
- [ ] タイムアウトが正しく機能する
- [ ] `docker stop`がPromiseを返す
- [ ] エラーハンドリングが正しく動作する
- [ ] リサイズ処理が正しくタイミング制御される

### 統合テスト
- [ ] Docker環境でのセッション作成・破棄が正しく動作する
- [ ] 親コンテナIDの永続化と復元が正しく動作する
- [ ] 孤立コンテナのクリーンアップが正しく動作する

### E2Eテスト（Playwright）
- [ ] Docker環境でのセッション作成→操作→削除が正しく動作する
- [ ] リサイズ操作が正しく動作する
- [ ] サーバー再起動後の復旧が正しく動作する

### 手動テスト
- [ ] Docker環境での起動・停止の安定性確認
- [ ] コンテナクラッシュ時の挙動確認
- [ ] 長時間稼働での安定性確認
- [ ] 親コンテナIDの復元確認

### 障害テスト
- [ ] コンテナクラッシュ時の挙動
- [ ] ネットワーク切断時の挙動
- [ ] Dockerデーモン停止時の挙動
- [ ] ディスク容量不足時の挙動

## リスク

| リスク | 影響度 | 対策 |
|-------|--------|------|
| コンテナ起動時間の増加 | 中 | タイムアウト設定、起動待機の最適化 |
| 既存のDocker環境との互換性 | 中 | バージョンチェック、フォールバック実装 |
| 孤立コンテナの誤削除 | 低 | 慎重な条件判定、ログ記録 |
| パフォーマンスへの影響 | 低 | 非同期処理、効率的なDocker API使用 |

## 見積もり

- **設計**: 4時間
- **実装**: 12時間
- **テスト**: 8時間
- **合計**: 24時間（3日）

## 参照

- 元の実装計画: セッション管理の包括的改善計画 - ステップ3
- 関連Issue:
  - Processが停止する問題
  - Docker環境での表示・入力問題
- 既存実装: src/services/adapters/docker-adapter.ts
